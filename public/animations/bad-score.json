{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.24,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform float uTime;\nuniform vec2 uMousePos;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0.3137254901960784, 0, 0.0392156862745098);\ncase 1: return vec3(0.3137254901960784, 0, 0.0392156862745098);\ncase 2: return vec3(0.3137254901960784, 0, 0.0392156862745098);\ncase 3: return vec3(0.3137254901960784, 0, 0.0392156862745098);\ncase 4: return vec3(0.5450980392156862, 0, 0.09411764705882353);\ncase 5: return vec3(0.3137254901960784, 0, 0.0392156862745098);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}float getStop(int index) {\nswitch(index) {\ncase 0: return 0.0000;\ncase 1: return 0.2000;\ncase 2: return 0.4000;\ncase 3: return 0.6000;\ncase 4: return 0.8000;\ncase 5: return 0.9625;\ncase 6: return 0.0000;\ncase 7: return 0.0000;\ncase 8: return 0.0000;\ncase 9: return 0.0000;\ncase 10: return 0.0000;\ncase 11: return 0.0000;\ncase 12: return 0.0000;\ncase 13: return 0.0000;\ncase 14: return 0.0000;\ncase 15: return 0.0000;\ndefault: return 0.0;\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}vec3 linear_from_srgb(vec3 rgb) {\nreturn pow(max(rgb, vec3(0.0)), vec3(2.2));\n}vec3 srgb_from_linear(vec3 lin) {\nreturn pow(max(lin, vec3(0.0)), vec3(1.0/2.2));\n}vec3 safeCbrt(vec3 v) {\nreturn sign(v) * pow(abs(v), vec3(1.0/3.0));\n}vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) {\nconst mat3 kCONEtoLMS = mat3(\n0.4121656120, 0.2118591070, 0.0883097947,\n0.5362752080, 0.6807189584, 0.2818474174,\n0.0514575653, 0.1074065790, 0.6302613616);\nconst mat3 kLMStoCONE = mat3(\n4.0767245293, -1.2681437731, -0.0041119885,\n-3.3072168827, 2.6093323231, -0.7034763098,\n0.2307590544, -0.3411344290, 1.7068625689);\nvec3 lms1 = safeCbrt( kCONEtoLMS*lin1 );\nvec3 lms2 = safeCbrt( kCONEtoLMS*lin2 );\nvec3 lms = mix( lms1, lms2, a );\nlms *= 1.0 + 0.025 * a * (1.0-a);\nreturn kLMStoCONE * (lms * lms * lms);\n}vec3 getGradientColor(float position) {\nposition = clamp(position, 0.0, 1.0);\nif (6 <= 1) return getColor(0);for (int i = 0; i < 15; i++) {\nif (i >= 6 - 1) break;\nfloat stopA = getStop(i);\nfloat stopB = getStop(i + 1);\nif (position <= stopB || i == 6 - 2) {\nfloat denom = max(stopB - stopA, 0.00001);\nfloat t = clamp((position - stopA) / denom, 0.0, 1.0);\nvec3 linA = linear_from_srgb(getColor(i));\nvec3 linB = linear_from_srgb(getColor(i + 1));\nvec3 mixed = oklab_mix(linA, linB, t);\nreturn srgb_from_linear(mixed);\n}\n}\nreturn getColor(min(6 - 1, 15));\n}out vec4 fragColor;vec3 applyColorToPosition(float position) {\nvec3 color = vec3(0);\nposition -= (uTime * 0.01 + 0.0000);\nfloat cycle = floor(position);\nbool reverse = 1.0000 > 0.5 && int(cycle) % 2 == 0;\nfloat animatedPos = reverse ? 1.0 - fract(position) : fract(position);color = getGradientColor(animatedPos);\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor += dither;\nreturn color;\n}vec3 linearGrad(vec2 uv) {\nfloat position = (uv.x+0.5);\nreturn applyColorToPosition(position);\n}vec3 getGradient(vec2 uv) {\nreturn linearGrad(uv);\n}vec3 getColor(vec2 uv) {return getGradient(uv);return vec3(0.3137254901960784, 0, 0.0392156862745098);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= max(0.5500*2., 1e-5);\nuv = rotate(uv, (0.4050 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 0.7500);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":true},"id":"gradient"},{"breakpoints":[],"aspectRatio":1.8681081081081081,"userDownsample":1,"effects":[],"trackMouse":-0.15,"anchorPoint":8,"mouseMomentum":1,"mask":0,"maskDepthLayer":1,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"shape","width":-944.9999999999998,"widthMode":1,"height":962,"heightMode":1,"left":0.33246527777777785,"top":0.7567567567567568,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0.08235294117647059, 0.08235294117647059, 0.08235294117647059);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}uniform vec2 uArtboardResolution;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)), (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)), (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}const float TAU = 6.28318530718;\nconst float PI = 3.14159265;out vec4 fragColor;vec2 rotate2D(vec2 p, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}vec2 getAnchorOffsets() {\nreturn vec2(0.5, 0.5);\n}vec3 getFillColor(vec2 localPos, vec2 elementSize, float signedDist, float maxInset) {\nvec2 halfSize = elementSize * 0.5;\nvec2 p = localPos - halfSize;return getColor(0);\n}float sdBox(vec2 p, vec2 b) {\nvec2 d = abs(p) - b;\nreturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}float sdEllipse(vec2 p, vec2 ab) {\nvec2 q = p / ab;\nreturn (length(q) - 1.0) * min(ab.x, ab.y);\n}float sdShape(vec2 canvasPosPx, vec2 elementPosPx, vec2 elementSizePx, float rotationTurns) {\nvec2 p = vec2(0.0);\nvec2 halfSize = vec2(0.0);elementSizePx = abs(elementSizePx);vec2 centerPx = elementPosPx + elementSizePx * 0.5;\nvec2 rel = canvasPosPx - centerPx;\nvec2 local = rotate2D(rel, -rotationTurns * TAU) + elementSizePx * 0.5;\np = local - elementSizePx * 0.5;\nhalfSize = elementSizePx * 0.5;return sdEllipse(p, vec2(max(halfSize.x, 0.00001), max(halfSize.y, 0.00001)));\nreturn sdBox(p, halfSize);\n}vec4 sampleShape(vec2 canvasUV) {\nvec2 canvasPosPx = vec2(canvasUV.x * uArtboardResolution.x, (1.0 - canvasUV.y) * uArtboardResolution.y);float absWidth = -945.0000;\nfloat absHeight = 962.0000;if (1 == 2) {\nabsWidth = absHeight * 1.8681;\n} else if (1 == 2) {\nabsHeight = absWidth / 1.8681;\n}vec2 elementSizePx = vec2(absWidth, absHeight);\nvec2 elementPosPx = vec2(0.3325, 0.7568) * uArtboardResolution - getAnchorOffsets() * elementSizePx;float dist = sdShape(canvasPosPx, elementPosPx, elementSizePx, 0.0000);\nfloat aa = max(length(vec2(dFdx(dist), dFdy(dist))), 0.75);float fillAlpha = 1.0 - smoothstep(mix(0.0, -150., 0.0000), mix(aa, 150., 0.0000), dist);\nvec2 localPos;\nlocalPos = rotate2D(canvasPosPx - (elementPosPx + elementSizePx * 0.5), 0.0000 * -TAU) + elementSizePx * 0.5;\nvec2 localSize;\nlocalSize = elementSizePx;\nvec2 centerPx;\ncenterPx = elementPosPx + elementSizePx * 0.5;\nfloat centerDist = sdShape(centerPx, elementPosPx, elementSizePx, 0.0000);\nfloat maxInset = max(-centerDist, 0.00001);vec3 fillRgb = getFillColor(localPos, localSize, dist, maxInset);\nfloat finalFillAlpha = fillAlpha * 1.0000;\nvec4 fill = vec4(fillRgb * finalFillAlpha, finalFillAlpha);float strokeAlpha = 0.0;\nvec4 stroke = vec4(vec3(0, 0, 0) * strokeAlpha, strokeAlpha);\nvec4 col = stroke + fill * (1.0 - stroke.a);\nreturn col;\n}vec4 getNormalOutput(vec4 color, vec4 background) {\nvec3 unpremultColor = color.rgb / max(color.a, 0.0001);\nvec3 blendedColor = blend(5, unpremultColor, background.rgb);\ncolor = vec4(blendedColor, 1.0) * (color.a * 1.0000);\ncolor = color + background * (1.0 - color.a);\nreturn color;\nreturn mix(background, color + background * (1.0 - color.a), 1.0000);\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}vec4 getCompositeOutput(vec2 uv) {\nvec4 background = vec4(0.0);background = texture(uBgTexture, vTextureCoord);vec4 color = sampleShape(uv);return getOutputByMode(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = (uMousePos - 0.5) * -0.1500;uv -= pos;fragColor = getCompositeOutput(uv);\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{"artboardResolution":{"name":"uArtboardResolution","type":"2f","value":{"type":"Vec2","_x":1152,"_y":320}},"aspectRatio":{"name":"uAspectRatio","type":"1f","value":1.8681081081081081}}},"id":"shape"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"blur","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 0 <= 1 ? 6. : 11.;\nfloat amount = (2.8180 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 0 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 1 <= 1 ? 6. : 11.;\nfloat amount = (2.8180 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 1 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 2 <= 1 ? 6. : 11.;\nfloat amount = (2.8180 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 2 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 3 <= 1 ? 6. : 11.;\nfloat amount = (2.8180 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 3 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor.rgb += dither;\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"vertical","value":1,"downSample":0.25},{"prop":"vertical","value":2,"downSample":0.5},{"prop":"vertical","value":3,"downSample":0.5}]},"id":"blur"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"flowField","usesPingPong":false,"speed":0.1,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;float ease (int easingFunc, float t) {\nreturn t;\n}vec3 hash33(vec3 p3) {\np3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\np3 += dot(p3, p3.yxz + 19.19);\nreturn -1.0 + 2.0 * fract(vec3(\n(p3.x + p3.y) * p3.z,\n(p3.x + p3.z) * p3.y,\n(p3.y + p3.z) * p3.x\n));\n}float perlin_noise(vec3 p) {\nvec3 pi = floor(p);\nvec3 pf = p - pi;vec3 w = pf * pf * (3.0 - 2.0 * pf);float n000 = dot(pf - vec3(0.0, 0.0, 0.0), hash33(pi + vec3(0.0, 0.0, 0.0)));\nfloat n100 = dot(pf - vec3(1.0, 0.0, 0.0), hash33(pi + vec3(1.0, 0.0, 0.0)));\nfloat n010 = dot(pf - vec3(0.0, 1.0, 0.0), hash33(pi + vec3(0.0, 1.0, 0.0)));\nfloat n110 = dot(pf - vec3(1.0, 1.0, 0.0), hash33(pi + vec3(1.0, 1.0, 0.0)));\nfloat n001 = dot(pf - vec3(0.0, 0.0, 1.0), hash33(pi + vec3(0.0, 0.0, 1.0)));\nfloat n101 = dot(pf - vec3(1.0, 0.0, 1.0), hash33(pi + vec3(1.0, 0.0, 1.0)));\nfloat n011 = dot(pf - vec3(0.0, 1.0, 1.0), hash33(pi + vec3(0.0, 1.0, 1.0)));\nfloat n111 = dot(pf - vec3(1.0, 1.0, 1.0), hash33(pi + vec3(1.0, 1.0, 1.0)));float nx00 = mix(n000, n100, w.x);\nfloat nx01 = mix(n001, n101, w.x);\nfloat nx10 = mix(n010, n110, w.x);\nfloat nx11 = mix(n011, n111, w.x);float nxy0 = mix(nx00, nx10, w.y);\nfloat nxy1 = mix(nx01, nx11, w.y);float nxyz = mix(nxy0, nxy1, w.z);return nxyz;\n}const int MAX_ITERATIONS = 8;\nconst float PI = 3.14159265359;vec2 flow (in vec2 st) {\nfloat aspectRatio = uResolution.x / max(uResolution.y, 0.001);\nvec2 aspectVec = vec2(aspectRatio, 1.);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat mixRadiusStep = step(1.0, 1.0000);\nvec2 pos = mix(vec2(0.5, 0.5), mPos, mixRadiusStep);\nfloat dist = ease(0, max(0.,1. - length(st * aspectVec - mPos * aspectVec) * 4. * (1. - 1.0000)));float sprd = (0.2100 + 0.01) / ((aspectRatio + 1.) / 2.);\nfloat amt = (0.5900 * 2.0) * 0.01 * dist;\nif(amt <= 0.) {\nreturn st;\n}vec2 invPos = 1. - pos;\nfloat freq = 5. * sprd;\nfloat t = 0.0100 * 5. + uTime * 0.0166;\nfloat degrees = 360. * (0.5000 * 6.);\nfloat rad = degrees * PI / 180.;for (int i = 0; i < MAX_ITERATIONS; i++) {\nvec2 clampedSt = clamp(st, -1., 2.);\nvec2 scaled = (clampedSt - 0.5) * aspectVec + invPos;\nfloat perlin = perlin_noise(vec3((scaled - 0.5) * freq, t)) - 0.5;\nfloat ang = perlin * rad;\nst += vec2(cos(ang), sin(ang)) * amt;\n}return clamp(st, 0., 1.);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, mix(uv, flow(uv), 1.0000));\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"flow_field"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"grain","usesPingPong":false,"speed":0.5,"texture":false,"animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)), (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)), (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);if(color.a <= 0.001) {\nfragColor = vec4(0);\nreturn;\n}vec2 st = uv;\nvec3 grainRGB = vec3(0);st *= uResolution;float delta = fract((floor(uTime)/20.));if(1 == 1) {\ngrainRGB = vec3(\nrandFibo(st + vec2(1, 2) + delta),\nrandFibo(st + vec2(2, 3) + delta),\nrandFibo(st + vec2(3, 4) + delta)\n);\n} else {\ngrainRGB = vec3(randFibo(st + vec2(delta)));\n}\ncolor.rgb = mix(color.rgb, blend(5, grainRGB, color.rgb), 0.2100);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"grain"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"guilloche","usesPingPong":false,"speed":0.25,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uResolution;const float PI = 3.14159265359;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}float getWaveLine(vec2 uv, float intensity) {\nfloat lineFreq = 150.0 * 0.9500;\nfloat waveAmplitude = 0.04 * 0.0000;\nfloat waveFreq = 8.0 * 0.3600;\nfloat sineOffset = waveAmplitude * sin((uv.x + uTime*0.005) * waveFreq * 2.0 * 3.14159);\nuv.y += sineOffset;\nfloat lineWidth = mix(0., 1., intensity);float linePosition = fract(uv.y * lineFreq);\nfloat gradient = smoothstep(0., lineWidth, linePosition) - smoothstep(1.0 - lineWidth, 1.0, linePosition);return smoothstep(0., lineWidth*1.5, gradient*gradient);\n}float getZigZagLine(vec2 uv, float lineWidth) {\nfloat lineFreq = 150.0 * 0.9500;\nfloat waveAmplitude = 0.8 * 0.0000;\nfloat flipInterval = 0.2 * (1. - 0.3600 + 0.001);\nfloat flip = mod(floor(uv.x / flipInterval), 2.0);\nuv.x -= flipInterval * 0.5 + floor(uv.x / flipInterval) * flipInterval + uTime*0.005;\nuv = (uv * rot(waveAmplitude * (flip * 2.0 - 1.0)));\nuv.x += flipInterval * 0.5;float linePosition = fract(uv.y * lineFreq);float gradient = smoothstep(0.0, lineWidth, linePosition) - smoothstep(1.0 - lineWidth, 1.0, linePosition);\nreturn smoothstep(0., lineWidth*1.5, gradient*gradient);\n}float getGuillocheLine(vec2 uv, float lineWidth) {\nfloat lineFreq = 150.0 * 0.9500;\nfloat waveAmplitude = 0.04 * 0.0000;\nfloat waveFreq = 8.0 * 0.3600;\nuv.x += waveAmplitude * sin((uv.y + uTime*0.005) * waveFreq * 2.0 * 3.14159);float linePosition = fract(uv.x * lineFreq);float gradient = smoothstep(0.0, lineWidth, linePosition) - smoothstep(1.0 - lineWidth, 1.0, linePosition);\nreturn smoothstep(0., 1., gradient*gradient);\n}float getGuillocheFull(vec2 uv, float lineWidth) {\nfloat mult = getGuillocheLine(uv * rot(0.25 * 2. * PI), lineWidth) * 0.75;\nfloat add = getGuillocheLine(uv * rot(0.25 * 2. * PI), lineWidth) + getGuillocheLine(uv, lineWidth);\nreturn mix(add, mult, smoothstep(0., 1., lineWidth));\n}vec3 photoshop_desaturate(vec3 color)\n{\nfloat bw = (min(color.r, min(color.g, color.b)) + max(color.r, max(color.g, color.b))) * 0.5;\nreturn vec3(bw);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;vec4 color = texture(uTexture, uv);\nvec3 linographed = vec3(0);float red = 1.-color.r;\nfloat green = 1.-color.g;\nfloat blue = 1.-color.b;vec2 st = rot(0.0000 * -1. * 2. * PI) * ((uv * vec2(uResolution.x/uResolution.y, 1.)) - vec2(0.5, 0.5));\nif(1 == 0) {\nlinographed = vec3(\ngetGuillocheFull(st, red),\ngetGuillocheFull(st, green),\ngetGuillocheFull(st, blue)\n);\n}\nif(1 == 1) {\nlinographed = vec3(\ngetWaveLine(st, red),\ngetWaveLine(st, green),\ngetWaveLine(st, blue)\n);\n}\nif(1 == 2) {\nlinographed = vec3(\ngetZigZagLine(st, red),\ngetZigZagLine(st, green),\ngetZigZagLine(st, blue)\n);\n}color.rgb = mix(color.rgb, linographed, 0.0900);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"guilloche"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"dither","usesPingPong":false,"speed":0.5,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform sampler2D uBlueNoise;uniform float uTime;uniform vec2 uResolution;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const int MAX_LEVEL = 4;\nconst float PI2 = 6.28318530718;float getBlueNoise(vec2 st, float delta, float size) {\nivec2 texSize = textureSize(uBlueNoise, 0);\nvec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution/size)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0);\nreturn mod((blueNoise.r - 0.5) * PI2 + (delta * (1.0 / PI2)), PI2) / PI2 - 0.005;\n}vec3 dither(vec3 color, vec2 st) {\nfloat delta = floor(uTime);\nvec2 offset = vec2(randFibo(vec2(123,16) + delta), randFibo(vec2(56,96) + delta));\nfloat noise = 0.0;\nnoise = getBlueNoise(st, delta, 2.);\nfloat dither_threshold = max(0.0001, 0.0900);\nfloat num_levels = 1.0 / dither_threshold;\nreturn floor(color * num_levels + noise) / num_levels;\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nfloat delta = floor(uTime);\nvec4 color = texture(uTexture, uv);if(color.a == 0.) {\nfragColor = vec4(0);\nreturn;\n}color.rgb = mix(color.rgb, dither(color.rgb, vTextureCoord), 0.5000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}},"id":"dither"}],"options":{"name":"Copy of Hero","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"2.0.3","id":"63sPlT17HIrsQBlDbgOJ"}